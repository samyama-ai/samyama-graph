// OpenCypher Grammar for Pest Parser
// Implements basic subset of OpenCypher for Phase 2

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!"\n" ~ ANY)*) }

// Query structure
query = { SOI ~ explain_clause? ~ statement ~ ";"? ~ EOI }
explain_clause = { ^"EXPLAIN" }
statement = { create_vector_index_stmt | create_index_stmt | call_stmt | match_stmt | create_stmt }

// CREATE VECTOR INDEX statement
create_vector_index_stmt = { ^"CREATE" ~ ^"VECTOR" ~ ^"INDEX" ~ variable? ~ ^"FOR" ~ "(" ~ variable ~ ":" ~ label ~ ")" ~ ^"ON" ~ "(" ~ variable ~ "." ~ property_key ~ ")" ~ options? }
create_index_stmt = { ^"CREATE" ~ ^"INDEX" ~ ^"ON" ~ ":" ~ label ~ "(" ~ property_key ~ ")" }
options = { ^"OPTIONS" ~ "{" ~ property_list? ~ "}" }

// CALL statement (Standalone or followed by MATCH)
call_stmt = { call_clause ~ match_stmt_partial? ~ return_clause? }
match_stmt_partial = { ^"MATCH" ~ pattern ~ where_clause? }

// CALL clause
call_clause = { ^"CALL" ~ procedure_name ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" ~ (^"YIELD" ~ yield_items)? }
procedure_name = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | ".")* }
yield_items = { yield_item ~ ("," ~ yield_item)* }
yield_item = { variable ~ (^"AS" ~ variable)? }

// MATCH clause (can optionally have CALL or CREATE)
match_stmt = { ^"MATCH" ~ pattern ~ where_clause? ~ call_clause? ~ create_clause? ~ return_clause? ~ order_by_clause? ~ limit_clause? }
where_clause = { ^"WHERE" ~ expression }
create_clause = { ^"CREATE" ~ pattern }
return_clause = { ^"RETURN" ~ distinct? ~ return_items }
distinct = { ^"DISTINCT" }
order_by_clause = { ^"ORDER" ~ ^"BY" ~ order_items }
limit_clause = { ^"LIMIT" ~ integer }

// Standalone CREATE clause
create_stmt = { ^"CREATE" ~ pattern }

// Pattern matching
pattern = { path ~ ("," ~ path)* }
path = { node ~ (edge_pattern ~ node)* }

// Node pattern: (n:Person {name: "Alice"})
node = { "(" ~ variable? ~ labels? ~ properties? ~ ")" }
labels = { (":" ~ label)+ }
label = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Edge pattern: -[:KNOWS]-> or <-[:KNOWS]- or -[:KNOWS]-
edge_pattern = {
    ("<-" ~ edge_detail ~ "-") |
    ("-" ~ edge_detail ~ "->") |
    ("-" ~ edge_detail ~ "-")
}
edge_detail = { "[" ~ variable? ~ edge_types? ~ length_pattern? ~ properties? ~ "]" }
edge_types = { (":" ~ edge_type)+ }
edge_type = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Variable length: *1..5 or * or *3..
length_pattern = { "*" ~ (range_pattern | integer)? }
range_pattern = { integer? ~ ".." ~ integer? }

// Properties: {name: "Alice", age: 30}
properties = { "{" ~ property_list? ~ "}" }
property_list = { property ~ ("," ~ property)* }
property = { property_key ~ ":" ~ value }
property_key = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// RETURN items
return_items = { return_item ~ ("," ~ return_item)* }
return_item = { expression ~ (^"AS" ~ variable)? }

// ORDER BY items
order_items = { order_item ~ ("," ~ order_item)* }
order_item = { expression ~ order_direction? }
order_direction = { ^"ASC" | ^"DESC" }

// Expressions
expression = { term ~ (binary_op ~ term)* }
term = { unary_op* ~ primary ~ postfix_op? }
postfix_op = { ^"IS" ~ ^"NOT" ~ ^"NULL" | ^"IS" ~ ^"NULL" }
primary = {
    function_call |
    property_access |
    variable |
    value |
    "(" ~ expression ~ ")"
}

property_access = { variable ~ "." ~ property_key }
function_call = { function_name ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }
function_name = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Operators
mul_div_mod_op = { "*" | "/" | "%" }
add_sub_op = { "+" | "-" }
comparison_op = { "<=" | ">=" | "<" | ">" | "==" | "=~" | "=" | "!=" | "<>" | ^"STARTS" ~ ^"WITH" | ^"ENDS" ~ ^"WITH" | ^"CONTAINS" }
in_op = @{ ^"IN" ~ !(ASCII_ALPHANUMERIC | "_") }
and_op = @{ ^"AND" ~ !(ASCII_ALPHANUMERIC | "_") }
or_op = @{ ^"OR" ~ !(ASCII_ALPHANUMERIC | "_") }

binary_op = _{ mul_div_mod_op | add_sub_op | comparison_op | in_op | and_op | or_op }

unary_op = { ^"NOT" | "-" }

// Values
value = {
    null |
    boolean |
    float |
    integer |
    string |
    list |
    map
}

null = { ^"NULL" }
boolean = { ^"TRUE" | ^"FALSE" }
integer = @{ "-"? ~ ASCII_DIGIT+ }
float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ (^"e" ~ ("-" | "+")? ~ ASCII_DIGIT+)? }
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }
list = { "[" ~ (value ~ ("," ~ value)*)? ~ "]" }
map = { "{" ~ (map_entry ~ ("," ~ map_entry)*)? ~ "}" }
map_entry = { (string | property_key) ~ ":" ~ value }

// Variable names
variable = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
